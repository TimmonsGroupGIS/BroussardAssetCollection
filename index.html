<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapillary Viewer with ArcGIS Map</title>
    
    <!-- MapillaryJS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
    <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>
    
    <!-- MapLibre GL -->
    <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #viewer {
            width: 50%;
            height: 100%;
            position: relative;
        }
        #mini-map {
            position: absolute;
            bottom: 60px;
            right: 10px;
            width: 300px;
            height: 200px;
            border: 3px solid white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        #arcgis-container {
            width: 50%;
            height: 100%;
            position: relative;
        }
        #arcgis-map {
            width: 100%;
            height: 100%;
            border: none;
        }
        #sync-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #4285F4;
            color: white;
            font-weight: bold;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1001;
            transition: background 0.2s;
        }
        #sync-btn:hover {
            background: #3367D6;
        }
        #loading {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 13px;
        }
        #mini-map-loading {
            position: absolute;
            bottom: 130px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1001;
            display: none;
        }
        #mini-map-loading.visible {
            display: block;
        }
        #mapillary-link-btn {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: #34A853;
            color: white;
            font-weight: bold;
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            z-index: 1000;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #mapillary-link-btn:hover {
            background: #2D9348;
        }
        #mapillary-link-btn img {
            width: 30px;
            height: 30px;
        }
        #find-closest-btn {
            position: absolute;
            bottom: 60px;
            left: 10px;
            background: #FF9800;
            color: white;
            font-weight: bold;
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            z-index: 1000;
            transition: background 0.2s;
            max-width: 250px;
            text-align: center;
        }
        #find-closest-btn:hover {
            background: #F57C00;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="viewer">
            <div id="loading">Loading Mapillary viewer...</div>
            <div id="mini-map"></div>
            <div id="mini-map-loading">Loading map data...</div>
            <button id="find-closest-btn">üéØ Find Image Closest to ArcGIS Center</button>
            <button id="mapillary-link-btn">
                <img src="https://play-lh.googleusercontent.com/z3qzEc13E2sDWky9LgqADojcdy8hrX_szuAAeX21k_dFe7GNXLIYXJtOu5RcE3_5Jz8" alt="Mapillary">
                Open in Mapillary Web
            </button>
        </div>
        
        <div id="arcgis-container">
            <iframe id="arcgis-map" src="https://timmons-group.maps.arcgis.com/apps/mapviewer/index.html?webmap=0de90d7988f9470da59918c9b00c5379"></iframe>
            <button id="sync-btn">üìç Sync to Current Image</button>
        </div>
    </div>

    <script>
        const TOKEN = 'MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d';
        const START_ID = '1347465910083369';
        const USERNAME = 'vukmercd23';
        const START_DATE = '2025-10-01T00:00:00Z';
        const END_DATE = '2025-10-16T00:00:00Z';
        
        let imageData = [];
        let isUpdatingFromMap = false;

        // Initialize Mapillary Viewer
        const viewer = new mapillary.Viewer({
            container: 'viewer',
            accessToken: TOKEN,
            imageId: START_ID,
            component: {
                cover: false,
                sequence: true,
                direction: true,
                zoom: true
            }
        });

        // Initialize mini map
        const miniMap = new maplibregl.Map({
            container: 'mini-map',
            style: {
                version: 8,
                sources: {
                    osm: {
                        type: 'raster',
                        tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        attribution: '¬© OpenStreetMap'
                    }
                },
                layers: [
                    { id: 'osm', type: 'raster', source: 'osm' }
                ]
            },
            center: [-91.95221806850299, 30.138492112426093],
            zoom: 12
        });

        // Fetch user images
        async function fetchUserImages() {
            const loadingEl = document.getElementById('mini-map-loading');
            loadingEl.classList.add('visible');
            
            try {
                console.log('Starting to fetch images...');
                let allImages = [];
                let after = null;
                const startTime = Date.parse(START_DATE);
                const endTime = Date.parse(END_DATE);
                let requestCount = 0;
                
                while (true) {
                    const url = new URL('https://graph.mapillary.com/images');
                    url.searchParams.set('access_token', TOKEN);
                    url.searchParams.set('fields', 'id,geometry,sequence,captured_at');
                    url.searchParams.set('creator_username', USERNAME);
                    url.searchParams.set('limit', 2000);
                    if (after) url.searchParams.set('after', after);
                    
                    console.log(`Request ${++requestCount}...`);
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.error(`API Error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    const images = data.data || [];
                    console.log(`Got ${images.length} images`);
                    
                    if (images.length === 0) break;
                    
                    const filtered = images.filter(img => {
                        if (!img.captured_at) return false;
                        let capturedTime = typeof img.captured_at === 'number' ? 
                            img.captured_at : Date.parse(img.captured_at);
                        return capturedTime >= startTime && capturedTime < endTime;
                    });
                    
                    console.log(`Filtered to ${filtered.length} images in date range`);
                    allImages = allImages.concat(filtered);
                    loadingEl.textContent = `Loading: ${allImages.length} images...`;
                    
                    if (data.paging?.cursors?.after) {
                        after = data.paging.cursors.after;
                    } else {
                        break;
                    }
                    
                    if (requestCount >= 20 || allImages.length >= 50000) break;
                }
                
                console.log(`Total images loaded: ${allImages.length}`);
                imageData = allImages;
                loadingEl.classList.remove('visible');
                addImagesToMiniMap();
            } catch (err) {
                console.error('Error fetching images:', err);
                loadingEl.textContent = 'Error loading data';
                setTimeout(() => loadingEl.classList.remove('visible'), 3000);
            }
        }

        function addImagesToMiniMap() {
            console.log(`Adding ${imageData.length} images to mini map`);
            
            const features = imageData
                .filter(img => img.geometry?.coordinates)
                .map(img => ({
                    type: 'Feature',
                    geometry: { type: 'Point', coordinates: img.geometry.coordinates },
                    properties: { id: img.id }
                }));

            console.log(`Created ${features.length} features for map`);

            const addLayers = () => {
                if (miniMap.getSource('images')) {
                    console.log('Updating existing source');
                    miniMap.getSource('images').setData({ type: 'FeatureCollection', features });
                } else {
                    console.log('Adding new source and layers');
                    miniMap.addSource('images', {
                        type: 'geojson',
                        data: { type: 'FeatureCollection', features }
                    });

                    miniMap.addLayer({
                        id: 'image-points',
                        type: 'circle',
                        source: 'images',
                        paint: {
                            'circle-color': '#4285F4',
                            'circle-radius': 3,
                            'circle-stroke-width': 1,
                            'circle-stroke-color': '#1565C0'
                        }
                    });

                    // Current position marker
                    miniMap.addSource('current', {
                        type: 'geojson',
                        data: { type: 'FeatureCollection', features: [] }
                    });

                    miniMap.addLayer({
                        id: 'current-point',
                        type: 'circle',
                        source: 'current',
                        paint: {
                            'circle-color': '#EA4335',
                            'circle-radius': 6,
                            'circle-stroke-width': 2,
                            'circle-stroke-color': '#fff'
                        }
                    });

                    // FOV wedge layer
                    miniMap.addSource('fov', {
                        type: 'geojson',
                        data: { type: 'FeatureCollection', features: [] }
                    });

                    miniMap.addLayer({
                        id: 'fov-wedge',
                        type: 'fill',
                        source: 'fov',
                        paint: {
                            'fill-color': '#FBBC04',
                            'fill-opacity': 0.4
                        }
                    });

                    miniMap.addLayer({
                        id: 'fov-outline',
                        type: 'line',
                        source: 'fov',
                        paint: {
                            'line-color': '#F57C00',
                            'line-width': 2
                        }
                    });

                    // Click to jump
                    miniMap.on('click', 'image-points', async (e) => {
                        if (isUpdatingFromMap) return;
                        const feature = e.features[0];
                        const imageId = feature.properties.id;
                        if (imageId) {
                            isUpdatingFromMap = true;
                            try {
                                await viewer.moveTo(String(imageId));
                            } catch (err) {
                                console.error('Error moving to image:', err);
                            }
                            setTimeout(() => { isUpdatingFromMap = false; }, 300);
                        }
                    });

                    miniMap.on('mouseenter', 'image-points', () => {
                        miniMap.getCanvas().style.cursor = 'pointer';
                    });

                    miniMap.on('mouseleave', 'image-points', () => {
                        miniMap.getCanvas().style.cursor = '';
                    });
                }

                // Fit to show all images
                if (features.length > 0) {
                    const coords = features.map(f => f.geometry.coordinates);
                    const bounds = coords.reduce((bounds, coord) => {
                        return bounds.extend(coord);
                    }, new maplibregl.LngLatBounds(coords[0], coords[0]));
                    miniMap.fitBounds(bounds, { padding: 20 });
                    console.log('Fitted bounds to show all images');
                }
            };

            if (miniMap.loaded() || miniMap.isStyleLoaded?.()) {
                addLayers();
            } else {
                miniMap.once('load', addLayers);
            }
        }

        // Update mini map current position
        async function updateMiniMapPosition() {
            if (isUpdatingFromMap) return;
            try {
                const pos = await viewer.getPosition();
                const pov = await viewer.getPointOfView();
                
                // Update position marker
                if (miniMap.getSource('current')) {
                    miniMap.getSource('current').setData({
                        type: 'FeatureCollection',
                        features: [{
                            type: 'Feature',
                            geometry: { type: 'Point', coordinates: [pos.lng, pos.lat] }
                        }]
                    });
                }
                
                // Update FOV wedge
                if (miniMap.getSource('fov')) {
                    const fovDegrees = 90; // Approximate horizontal FOV
                    const radius = 0.0002; // Wedge size in degrees (adjust for visibility)
                    const bearing = pov.bearing;
                    
                    // Create wedge polygon
                    const wedge = createFOVWedge(pos.lng, pos.lat, bearing, fovDegrees, radius);
                    
                    miniMap.getSource('fov').setData({
                        type: 'FeatureCollection',
                        features: [{
                            type: 'Feature',
                            geometry: {
                                type: 'Polygon',
                                coordinates: [wedge]
                            }
                        }]
                    });
                }
            } catch (err) {
                console.error('Error updating mini map:', err);
            }
        }

        // Create FOV wedge coordinates
        function createFOVWedge(lng, lat, bearing, fovDegrees, radius) {
            const points = [[lng, lat]]; // Start at center
            const halfFOV = fovDegrees / 2;
            const numPoints = 20; // Number of points along the arc
            
            // Create arc points
            for (let i = 0; i <= numPoints; i++) {
                const angle = bearing - halfFOV + (fovDegrees * i / numPoints);
                const angleRad = angle * Math.PI / 180;
                
                const dx = radius * Math.sin(angleRad);
                const dy = radius * Math.cos(angleRad);
                
                points.push([lng + dx, lat + dy]);
            }
            
            points.push([lng, lat]); // Close the wedge
            return points;
        }

        viewer.on('load', () => {
            document.getElementById('loading').style.display = 'none';
            updateMiniMapPosition();
        });
        viewer.on('image', updateMiniMapPosition);
        viewer.on('position', updateMiniMapPosition);
        viewer.on('pov', updateMiniMapPosition);

        // Open in Mapillary web
        document.getElementById('mapillary-link-btn').addEventListener('click', () => {
            window.open('https://www.mapillary.com/app/user/vukmercd23?lat=30.138492112426093&lng=-91.95221806850299&z=12.85546044226375&dateFrom=2025-10-01&username%5B%5D=vukmercd23&dateTo=2025-10-15&pKey=1347465910083369', '_blank');
        });

        // Find closest image to ArcGIS map center
        document.getElementById('find-closest-btn').addEventListener('click', () => {
            try {
                // Try to get ArcGIS iframe URL
                const iframe = document.getElementById('arcgis-map');
                let arcgisUrl;
                
                try {
                    arcgisUrl = iframe.contentWindow.location.href;
                } catch (e) {
                    // Cross-origin restriction - use the src instead
                    arcgisUrl = iframe.src;
                }
                
                console.log('ArcGIS URL:', arcgisUrl);
                
                // Parse center from URL
                const url = new URL(arcgisUrl);
                const centerParam = url.searchParams.get('center');
                
                let targetLng, targetLat;
                
                if (centerParam) {
                    // Format: "lng,lat"
                    const parts = centerParam.split(',');
                    targetLng = parseFloat(parts[0]);
                    targetLat = parseFloat(parts[1]);
                    console.log('Parsed center:', targetLng, targetLat);
                } else {
                    alert('Could not find center coordinates in ArcGIS map URL. Please sync the ArcGIS map first, or pan to a location and sync.');
                    return;
                }
                
                if (isNaN(targetLng) || isNaN(targetLat)) {
                    alert('Invalid coordinates found. Please sync the ArcGIS map first.');
                    return;
                }
                
                if (imageData.length === 0) {
                    alert('Image data still loading. Please wait a moment and try again.');
                    return;
                }
                
                // Find closest image using Haversine distance
                let closestImage = null;
                let minDistance = Infinity;
                
                for (const img of imageData) {
                    if (!img.geometry?.coordinates) continue;
                    
                    const [lng, lat] = img.geometry.coordinates;
                    const distance = getDistance(targetLat, targetLng, lat, lng);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestImage = img;
                    }
                }
                
                if (closestImage) {
                    console.log('Found closest image:', closestImage.id, 'Distance:', minDistance.toFixed(2), 'meters');
                    
                    // Jump to the image
                    viewer.moveTo(String(closestImage.id)).catch(err => {
                        console.error('Error moving to image:', err);
                        alert('Could not jump to image. Please try again.');
                    });
                    
                    // Center mini map on the location
                    if (closestImage.geometry?.coordinates) {
                        miniMap.flyTo({
                            center: closestImage.geometry.coordinates,
                            zoom: 16,
                            duration: 1000
                        });
                    }
                    
                    // Visual feedback
                    const btn = document.getElementById('find-closest-btn');
                    const originalText = btn.textContent;
                    btn.textContent = `‚úì Found! (${minDistance.toFixed(0)}m away)`;
                    btn.style.background = '#34A853';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#FF9800';
                    }, 3000);
                } else {
                    alert('No images found near the ArcGIS map center.');
                }
                
            } catch (err) {
                console.error('Error finding closest image:', err);
                alert('Error: ' + err.message);
            }
        });

        // Calculate distance between two lat/lng points in meters (Haversine formula)
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // Distance in meters
        }

        // Sync ArcGIS map to current viewer position
        document.getElementById('sync-btn').addEventListener('click', async () => {
            try {
                const pos = await viewer.getPosition();
                const arcgisZoom = 18;
                
                const iframe = document.getElementById('arcgis-map');
                const baseUrl = 'https://timmons-group.maps.arcgis.com/apps/mapviewer/index.html';
                const newUrl = `${baseUrl}?webmap=0de90d7988f9470da59918c9b00c5379&center=${pos.lng},${pos.lat}&level=${arcgisZoom}`;
                iframe.src = newUrl;
                
                const btn = document.getElementById('sync-btn');
                const originalText = btn.textContent;
                btn.textContent = '‚úì Synced!';
                btn.style.background = '#34A853';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#4285F4';
                }, 2000);
            } catch (err) {
                console.error('Error syncing to ArcGIS:', err);
                alert('Could not sync position. Please try again.');
            }
        });

        // Load images
        fetchUserImages();
    </script>
</body>
</html>
